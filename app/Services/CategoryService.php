<?php

namespace App\Services;

use App\Helpers\Paginator;
use App\Repositories\CategoryRepository;
use App\Repositories\FilterRepository;
use App\Repositories\ProductRepository;

/**
 * Class CategoryService
 * @package App\Services
 */
class CategoryService extends LayoutService
{
    /**
     * @var CategoryRepository
     */
    public $categoryRepository;

    /**
     * @var ProductRepository
     */
    public $productRepository;

    /**
     * @var FilterRepository
     */
    public $filterRepository;

    /**
     * CategoryService constructor.
     * @param CategoryRepository $categoryRepository
     * @param ProductRepository $productRepository
     * @param FilterRepository $filterRepository
     */
    public function __construct(CategoryRepository $categoryRepository,
                                ProductRepository $productRepository,
                                FilterRepository $filterRepository)
    {
        parent::__construct($categoryRepository);

        $this->categoryRepository = $categoryRepository;

        $this->productRepository = $productRepository;

        $this->filterRepository = $filterRepository;
    }

    /**
     * @param $model
     */
    public function fill($model)
    {
//        try
//        {
            parent::fill($model); // TODO: Change the autogenerated stub

            $this->fillCurrentCategory($model);

            $this->fillCategoryProducts($model);

            $this->fillCountCategoryProducts($model);

            $this->fillFilters($model);

            $this->fillPriceMin($model);

            $this->fillPriceMax($model);

            $this->fillMetaTags($model);

            $this->fillSeoTags($model);
//        }
//        catch (\Exception $e)
//        {
//            abort(404);
//        }
    }

    /**
     * fill category
     * @param $model
     */
    private function fillCurrentCategory($model)
    {
        $model->currentCategory = $this->categoryRepository->getCurrentCategoryBySlug($model);

//        if (empty($model->currentCategory) || !isset($model->currentCategory) || is_null($model->currentCategory))
//        {
//            abort(404);
//        }
    }

    /**
     * fill products for category
     * @param $model
     */
    private function fillCategoryProducts($model)
    {
        $model->categoryProducts = $this->productRepository->getAllProductsForCategory($model);

        if (!is_null($model->categoryProducts) && $model->categoryProducts->count() > 0)
        {
            foreach ($model->categoryProducts as $product)
            {
                $product->currentSizeId = $product->sizes[0]->id;
            }
        }

//        if (empty($model->categoryProducts) || !isset($model->categoryProducts) || is_null($model->categoryProducts) || $model->categoryProducts->count() < 1)
//        {
//            abort(404);
//        }
    }

    /**
     * fill count of category products
     * @param $model
     */
    private function fillCountCategoryProducts($model)
    {
        $model->countCategoryProducts = $this->productRepository->getCountProductsCategory($model);
    }

    /**
     * fill filters for category
     * @param $model
     */
    private function fillFilters($model)
    {

        $filtersArray = $this->filterRepository->initFilters($model);

        $filters = [];

        foreach (collect($filtersArray) as $item)
        {
            $filterName = $item->filter_name_title;

            $item->isChecked = false;

            $filters[$filterName][] = $item;
        }

        $model->filters = collect($filters);
    }

    /**
     * fill min price
     * @param $model
     */
    private function fillPriceMin($model)
    {
        $model->priceMin = $this->productRepository->getPriceMinForCategoryProducts($model);
    }

    /**
     * fill max price
     * @param $model
     */
    private function fillPriceMax($model)
    {
        $model->priceMax = $this->productRepository->getPriceMaxForCategoryProducts($model);
    }

    private function fillMetaTags($model)
    {
        if (!is_null($model->currentCategory->meta_title))
        {
            $model->title = $model->currentCategory->meta_title;
            $model->description = $model->currentCategory->meta_description;
            $model->keywords = $model->currentCategory->meta_keywords;
            $model->h1 = $model->currentCategory->meta_h1;
        }
        else
        {
            $model->title = 'Outlet';
            $model->description = 'Outlet';
            $model->keywords = 'Outlet';
            $model->h1 = 'Outlet';
        }
    }

    private function fillSeoTags($model)
    {
        $pages = Paginator::createPagination($model->page, $model->categoryProductsLimit, $model->countCategoryProducts);

        $isPrev = array_shift($pages);

        $isNext = array_pop($pages);

        if ($isPrev)
        {
            $model->metaLinkPrev = url_category_per_page($model->currentCategory->slug . ($model->sort == 'default' ? '' : '/' . $model->sort), $model->page - 1, $model->language);
        }

        if ($isNext)
        {
            $model->metaLinkNext = url_category_per_page($model->currentCategory->slug . ($model->sort == 'default' ? '' : '/' . $model->sort), $model->page + 1, $model->language);
        }

        if ((int)$model->page > 1)
        {
            $model->setNoIndex = true;
        }

        if ($model->sort != 'default')
        {
            $model->setNoIndex = true;
        }
    }
}